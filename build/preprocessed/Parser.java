// Класс для разбора файла настроек и файла расписаний

// <editor-fold defaultstate="collapsed" desc=" Подключаемые модули ">

import java.io.*;
import java.util.*;

import javax.microedition.midlet.*;
import javax.microedition.lcdui.*;

// </editor-fold>


public class Parser {

    // <editor-fold defaultstate="collapsed" desc=" Поля класса ">

    // Элементы разбора.
    static final public byte ЭЛЕМЕНТ_НЕИЗВЕСТЕН = 0;
    static final public byte ЭЛЕМЕНТ_ИМЯ = 1;
    static final public byte ЭЛЕМЕНТ_ЧИСЛО = 2;
    static final public byte ЭЛЕМЕНТ_КОНЕЦ = 3;
    static final public byte ЭЛЕМЕНТ_ПЛЮС = 4;
    static final public byte ЭЛЕМЕНТ_МИНУС = 5;
    static final public byte ЭЛЕМЕНТ_УМНОЖИТЬ = 6;
    static final public byte ЭЛЕМЕНТ_ДЕЛИТЬ = 7;
    static final public byte ЭЛЕМЕНТ_РАВНО = 8;
    static final public byte ЭЛЕМЕНТ_ЛЕВАЯСКОБКА = 9;
    static final public byte ЭЛЕМЕНТ_ПРАВАЯСКОБКА = 10;
    static final public byte ЭЛЕМЕНТ_СТЕПЕНЬ = 11;
    static final public byte ЭЛЕМЕНТ_ВЫВОД = 12;
    static final public byte ЭЛЕМЕНТ_ЗАПЯТАЯ = 13;
    static final public byte ЭЛЕМЕНТ_ЛЕВАЯКВАДРСКОБКА = 14;
    static final public byte ЭЛЕМЕНТ_ПРАВАЯКВАДРСКОБКА = 15;
    static final public byte ЭЛЕМЕНТ_ФАКТОРИАЛ = 16;
    static final public byte ЭЛЕМЕНТ_БОЛЬШЕ = 17;
    static final public byte ЭЛЕМЕНТ_МЕНЬШЕ = 18;
    static final public byte ЭЛЕМЕНТ_МЕНЬШЕРАВНО = 19;
    static final public byte ЭЛЕМЕНТ_БОЛЬШЕРАВНО = 20;
    static final public byte ЭЛЕМЕНТ_НЕРАВНО = 21;
    static final public byte ЭЛЕМЕНТ_МЕНЬШЕБОЛЬШЕ = 21;
    static final public byte ЭЛЕМЕНТ_ДВОЕТОЧИЕ = 22;
    static final public byte ЭЛЕМЕНТ_ПРИСВОИТЬ = 23;
    static final public byte ЭЛЕМЕНТ_ТЕКСТ = 24;
    static final public byte ЭЛЕМЕНТ_КАВЫЧКИ = 25;
    static final public byte ЭЛЕМЕНТ_КЛЮЧЕВОЕ_СЛОВО = 26;
    static final public byte ЭЛЕМЕНТ_ПОДЧЁРКИВАНИЕ = 27;
    static final public byte ЭЛЕМЕНТ_КОММЕНТАРИЙ = 28;

    // Свойства элементов таблицы переменных.
    static final public byte СВОЙСТВО_КОНСТАНТА = 0;
    static final public byte СВОЙСТВО_ПЕРЕМЕННАЯ = 1;
    static final public byte СВОЙСТВО_ФУНКЦИЯ = 2;

    // Поддерживаемые парсером типы.
    static final public byte ТИП_НЕИЗВЕСТЕН = 0;
    static final public byte ТИП_СКАЛЯР = 1;
    static final public byte ТИП_СТРОКА = 2;
    static final public byte ТИП_ВЕКТОР_1x1 = 3;
    static final public byte ТИП_ВЕКТОР_СТОЛБЕЦ = 4;
    static final public byte ТИП_ВЕКТОР_СТРОКА = 5;
    static final public byte ТИП_МАТРИЦА = 6;
    static final public byte ТИП_ЛОГИКА = 7;
    static final public byte ТИП_ПУТЬ = 8;

    // Идентификаторы ошибок.
    static final public byte ОШИБОК_НЕТ = 0;
    static final public byte ОШИБКА_НЕИЗВЕСТНАЯ = 1;
    static final public byte ОШИБКА_НЕИЗВЕСТНОЕ_ИМЯ = 2;
    static final public byte ОШИБКА_ТАБЛИЦА_ПУСТА = 3;
    static final public byte ОШИБКА_ИЗМЕНИТЬ_НЕЛЬЗЯ = 4;
    static final public byte ОШИБКА_НЕСООТВЕТСТВИЕ_ТИПА = 5;
    static final public byte ОШИБКА_НЕИЗВЕСТНЫЙ_ЭЛЕМЕНТ_РАЗБОРА = 6;
    static final public byte ОШИБКА_ОЖИДАЕТСЯ_ПРАВАЯ_КВАДР_СКОБКА = 7;
    static final public byte ОШИБКА_ОЖИДАЕТСЯ_ПРАВАЯ_СКОБКА = 8;
    static final public byte ОШИБКА_ДЕЛЕНИЕ_НА_НОЛЬ = 9;
    static final public byte ОШИБКА_ПРИ_ПРИСВОЕНИИ = 10;
    static final public byte ОШИБКА_НЕИЗВЕСТНОЕ_ИМЯ_ЭЛЕМ_РАЗБОРА = 11;
    static final public byte ОШИБКА_НЕИЗВЕСТНЫЙ_СИМВОЛ = 12;
    static final public byte ОШИБКА_НЕИЗВЕСТНОЕ_ИМЯ_ФУНКЦИИ = 13;
    static final public byte ОШИБКА_ОЖИДАЕТСЯ_ВЫРАЖЕНИЕ = 14;
    static final public byte ОШИБКА_НЕИЗВЕСТНЫЙ_ИДЕНТИФИКАТОР = 15;
    static final public byte ОШИБКА_ОЖИДАЕТСЯ_ОПЕРАНД = 16;
    static final public byte ОШИБКА_ОЖИДАЕТСЯ_ВЫВОД = 17;
    static final public byte ОШИБКА_ОЖИДАЕТСЯ_КАВЫЧКА = 18;
    static final public byte ОШИБКА_НЕИЗВЕСТНОЕ_КЛЮЧЕВОЕ_СЛОВО = 19;

    // Ошибки при чтении файла.
    static final public byte ОШИБКА_ОТКРЫТИЯ_ФАЙЛА = 0;

    String Текст;

    ОбразСвойств Свойства;

    InputStream ВходнойПоток = null;
    ОбразПеременных Переменные = null;

    private MIDlet Мидлет;
    private Display Дисплей;
    private Schedules МенеджерРасписаний;
    private Settings Настройки;

    // </editor-fold>

    public void ПоказатьСообщениеОбОшибке( int КодОшибки ) {

        String ТекстОшибки = "";

        switch ( КодОшибки ) {
            case ОШИБОК_НЕТ:
                break;
            case ОШИБКА_НЕИЗВЕСТНОЕ_ИМЯ:
                ТекстОшибки = "Неизвестное имя";
                break;
            case ОШИБКА_ТАБЛИЦА_ПУСТА:
                ТекстОшибки = "Таблица пуста";
                break;
            case ОШИБКА_ИЗМЕНИТЬ_НЕЛЬЗЯ:
                ТекстОшибки = "Изменить нельзя";
                break;
            case ОШИБКА_НЕСООТВЕТСТВИЕ_ТИПА:
                ТекстОшибки = "Несоответствие типа";
                break;
            case ОШИБКА_НЕИЗВЕСТНЫЙ_ЭЛЕМЕНТ_РАЗБОРА:
                ТекстОшибки = "Неизвестный элемент разбора";
                break;
            case ОШИБКА_ОЖИДАЕТСЯ_ПРАВАЯ_КВАДР_СКОБКА:
                ТекстОшибки = "Ожидается ']'";
                break;
            case ОШИБКА_ОЖИДАЕТСЯ_ПРАВАЯ_СКОБКА:
                ТекстОшибки = "Ожидается ')'";
                break;
            case ОШИБКА_ДЕЛЕНИЕ_НА_НОЛЬ:
                ТекстОшибки = "Деление на ноль";
                break;
            case ОШИБКА_ПРИ_ПРИСВОЕНИИ:
                ТекстОшибки = "Ошибка при присвоении";
                break;
            case ОШИБКА_НЕИЗВЕСТНОЕ_ИМЯ_ЭЛЕМ_РАЗБОРА:
                ТекстОшибки = "Неизвестное имя элемента разбора";
                break;
            case ОШИБКА_НЕИЗВЕСТНЫЙ_СИМВОЛ:
                ТекстОшибки = "Неизвестный символ";
                break;
            case ОШИБКА_НЕИЗВЕСТНОЕ_ИМЯ_ФУНКЦИИ:
                ТекстОшибки = "Неизвестное имя функции";
                break;
            case ОШИБКА_ОЖИДАЕТСЯ_ВЫРАЖЕНИЕ:
                ТекстОшибки = "Ожидается выражение";
                break;
            case ОШИБКА_НЕИЗВЕСТНЫЙ_ИДЕНТИФИКАТОР:
                ТекстОшибки = "Неизвестный идентификатор";
                break;
            case ОШИБКА_ОЖИДАЕТСЯ_ОПЕРАНД:
                ТекстОшибки = "Ожидается операнд";
                break;
            case ОШИБКА_ОЖИДАЕТСЯ_ВЫВОД:
                ТекстОшибки = "Ожидается ';'";
                break;
            case ОШИБКА_ОЖИДАЕТСЯ_КАВЫЧКА:
                ТекстОшибки = "Ожидается '\"'";
                break;
            case ОШИБКА_НЕИЗВЕСТНОЕ_КЛЮЧЕВОЕ_СЛОВО:
                ТекстОшибки = "Неизвестное ключевое слово";
                break;
            default:
                ТекстОшибки = "Неизвестная ошибка";
        }

        String ОтладИнформ = "Ошибка [" + КодОшибки + "]: " + ТекстОшибки + "\n";
        int нач, кон;

        нач = ( ( (int) Свойства.Позиция - 3 ) < 1 ) ? 1 : (int) Свойства.Позиция - 3;
        кон = ( ( (int) Свойства.Позиция + 3 ) > (int) Свойства.Размер ) ? (int) Свойства.Размер : (int) Свойства.Позиция + 3;

        ОтладИнформ += "Отладка:\n";
        ОтладИнформ += "\"" + Текст.substring( нач, кон ).trim() + "\"\n";
        ОтладИнформ += "Позиция: " + Integer.toString( (int) Свойства.Позиция ) + "\n";
        ОтладИнформ += Integer.toString( Свойства.ПредыдущЭлемент ) + "\n";
        ОтладИнформ += Integer.toString( Свойства.ТекущийЭлемент ) + "\n";
        ОтладИнформ += "Число: " + Integer.toString( Свойства.ЧислоЗначение ) + "\n";
        ОтладИнформ += "Имя: " + Свойства.ИмяЗначение + "\n";
        ОтладИнформ += "Длина: " + Integer.toString( (int) Свойства.Размер ) + "\n";
        ОтладИнформ += Текст.substring( 1, 4 ) + "...\n";
        ОтладИнформ += "Переменных: " + Integer.toString( Переменные.Имена.size() );

        Дисплей.setCurrent( new Alert( "Сообщение", ОтладИнформ, null , AlertType.ERROR ) );

        main.Логгер.info( "[Parser.java]: "
                + "Ошибка [" + КодОшибки + "]: " + ТекстОшибки + "\n"
                + "Отладочная информация:\n"
                + "Место ошибки: " + "\"" + Текст.substring( нач, кон ).trim() + "\"\n"
                + "Позиция: " + Integer.toString( ( int ) Свойства.Позиция ) + "\n"
                + "Предыдущий элемент: " + Integer.toString( Свойства.ПредыдущЭлемент ) + "\n"
                + "Текущий элемент: " + Integer.toString( Свойства.ТекущийЭлемент ) + "\n"
                + "Число: " + Integer.toString( Свойства.ЧислоЗначение ) + "\n"
                + "Имя: " + "\"" + Свойства.ИмяЗначение + "\"\n"
                + "Длина: " + Integer.toString( ( int ) Свойства.Размер ) + "\n"
                + "Переменных: " + Integer.toString( Переменные.Имена.size() ) + "\n"
                + "Текст: \"" + Текст.substring( 1, 4 ) + "...\"\n"
                );

    }

    public class ИсключениеРазборщика extends Exception {

        public ИсключениеРазборщика( int КодОшибки ) {

            ПоказатьСообщениеОбОшибке( КодОшибки );
        }

    }

    public class ОбразСвойств {

        int ТекущийЭлемент;
        int ПредыдущЭлемент;
        int ЧислоЗначение;
        long Позиция;
        long Размер;
        String ИмяЗначение;
        String СтрокаЗначение;

        ОбразСвойств() {
        }

        ОбразСвойств( ОбразСвойств свойства ) {

            ТекущийЭлемент = свойства.ТекущийЭлемент;
            ПредыдущЭлемент = свойства.ПредыдущЭлемент;
            ЧислоЗначение = свойства.ЧислоЗначение;
            Позиция = свойства.Позиция;
            Размер = свойства.Размер;
            ИмяЗначение = свойства.ИмяЗначение;
            СтрокаЗначение = свойства.СтрокаЗначение;
        }

    }


    public class ОбразПеременных {

        private Vector Имена;
        private Vector Значения;
        private Vector Свойства;

        public ОбразПеременных() {

            Имена = new Vector();
            Значения = new Vector();
            Свойства = new Vector();
        }

        public void ДобавитьЭлемент( String имя, int свойство, ОбразРезультата значение ) {

            Имена.addElement( имя );
            Свойства.addElement( new Integer( свойство ) );
            Значения.addElement( значение );
        }

        public boolean ИмяВТаблице( String имя ) {

            String строка;

            for ( Enumeration e = Имена.elements(); e.hasMoreElements(); ) {

                строка = ( String ) e.nextElement();
                if ( строка.equals( имя )  ) return true;
            }

            return false;
        }

        public int СвойствоЭлемента( String имя ) {
            int ii;
            Integer рез;
            String строка;

            for ( ii = 0; ii < Имена.size(); ii ++ ) {
                строка = ( String ) Имена.elementAt( ii );
                if ( строка.equals( имя )  ) {
                    рез = ( Integer ) Свойства.elementAt( ii );
                    return рез.intValue();
                }
            }

            return ТИП_НЕИЗВЕСТЕН;
        }

        public ОбразРезультата ЗначениеЭлемента( String имя ) {
            int ii;
            String строка;

            for ( ii = 0; ii < Имена.size(); ii ++ ) {
                строка = ( String ) Имена.elementAt( ii );
                if ( строка.equals( имя )  ) {
                    return ( ОбразРезультата ) Значения.elementAt( ii );
                }
            }

            return null;
        }

        public void ИзменитьЭлемент( String имя, int свойство, ОбразРезультата новоезначение ) {
            int ii;
            String строка;

            for ( ii = 0; ii < Имена.size(); ii ++ ) {
                строка = ( String ) Имена.elementAt( ii );
                if ( строка.equals( имя )  ) {
                    // Удаляем старую запись
                    Имена.removeElementAt( ii );
                    Свойства.removeElementAt( ii );
                    Значения.removeElementAt( ii );

                    // Добавляем новую запись
                    Имена.addElement( имя );
                    Свойства.addElement( new Integer( свойство ) );
                    Значения.addElement( новоезначение );

                    return;
                }

            }

        }

    }


    public class ОбразРезультата {

        Vector Размер = null;
        Vector Значение = null;
        Vector Тип = null;

        // Пустой конструктор.
        ОбразРезультата() {
        }


        // Конструктор для ТИП_СКАЛЯР.
        ОбразРезультата( int Число ) {
            Размер = new Vector();
            Значение = new Vector();
            Тип = new Vector();

            Размер.addElement( new Integer(1) );
            Значение.addElement( new Integer( Число ) );
            Тип.addElement( new Integer( ТИП_СКАЛЯР ) );
        }


        // Конструктор для ТИП_ЛОГИКА.
        ОбразРезультата( boolean Логика ) {
            Размер = new Vector();
            Значение = new Vector();
            Тип = new Vector();

            Размер.addElement( new Integer(1) );
            Значение.addElement( new Boolean( Логика ) );
            Тип.addElement( new Integer( ТИП_ЛОГИКА ) );
        }


        // Конструктор для ТИП_СТРОКА.
        ОбразРезультата( String Текст ) {

            Размер = new Vector();
            Значение = new Vector();
            Тип = new Vector();

            Размер.addElement( new Integer(1) );
            Значение.addElement( new String( Текст ) );
            Тип.addElement( new Integer( ТИП_СТРОКА ) );
        }


        // Конструктор для ТИП_ВЕКТОР_1x1, ТИП_ВЕКТОР_СТОЛБЕЦ, ТИП_ВЕКТОР_СТРОКА, ТИП_МАТРИЦА.
        ОбразРезультата( int строк, int столбцов, Vector данные ) {

            Размер = new Vector();
            Значение = new Vector();
            Тип = new Vector();

            Размер.addElement( new Integer( строк ) );
            Размер.addElement( new Integer( столбцов ) );
            Значение.addElement( данные );

            if ( ( строк == 1 ) && ( столбцов == 1 ) ) {

                Тип.addElement( new Integer( ТИП_ВЕКТОР_1x1 ) );

            } else if ( ( строк >= 1 ) && ( столбцов == 1 ) ) {

                Тип.addElement( new Integer( ТИП_ВЕКТОР_СТОЛБЕЦ ) );

            } else if ( ( строк == 1 ) && ( столбцов >= 1 ) ) {

                Тип.addElement( new Integer( ТИП_ВЕКТОР_СТРОКА ) );

            } else if ( ( строк >= 1 ) && ( столбцов >= 1 ) ) {

                Тип.addElement( new Integer( ТИП_МАТРИЦА ) );
            }

        }

    }

    // <editor-fold desc=" Конструктор ">

    public Parser( MIDlet мидлет, Settings Настройки  ) {

        Мидлет = мидлет;
        Дисплей = Display.getDisplay( Мидлет );
        МенеджерРасписаний = null;
        this.Настройки = Настройки;

        Свойства = new ОбразСвойств();

        Свойства.Позиция = -1;
        Свойства.Размер = 0;
        Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_ВЫВОД;
        Свойства.ПредыдущЭлемент = ЭЛЕМЕНТ_ВЫВОД;

        Свойства.ЧислоЗначение = 0;
        Свойства.ИмяЗначение = "";
        Свойства.СтрокаЗначение = "";

        Переменные = new ОбразПеременных();
    }


    public Parser( MIDlet мидлет, Settings Настройки, String Текст ) {

        Мидлет = мидлет;
        Дисплей = Display.getDisplay( Мидлет );
        МенеджерРасписаний = null;
        this.Настройки = Настройки;

        Свойства = new ОбразСвойств();

        Свойства.Позиция = -1;
        Свойства.Размер = 0;
        Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_ВЫВОД;
        Свойства.ПредыдущЭлемент = ЭЛЕМЕНТ_ВЫВОД;

        Свойства.ЧислоЗначение = 0;
        Свойства.ИмяЗначение = "";
        Свойства.СтрокаЗначение = "";

        this.Текст = Текст;
        Свойства.Размер = Текст.length();

        Переменные = new ОбразПеременных();
    }


    public Parser( MIDlet мидлет, Schedules менеджер, Settings Настройки ) {

        Мидлет = мидлет;
        Дисплей = Display.getDisplay( Мидлет );
        МенеджерРасписаний = менеджер;
        this.Настройки = Настройки;

        Свойства = new ОбразСвойств();

        Свойства.Позиция = -1;
        Свойства.Размер = 0;
        Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_ВЫВОД;
        Свойства.ПредыдущЭлемент = ЭЛЕМЕНТ_ВЫВОД;

        Свойства.ЧислоЗначение = 0;
        Свойства.ИмяЗначение = "";
        Свойства.СтрокаЗначение = "";

        Переменные = new ОбразПеременных();
    }

    public Parser( MIDlet мидлет, Schedules менеджер, Settings Настройки, String Текст ) {

        Мидлет = мидлет;
        Дисплей = Display.getDisplay( Мидлет );
        МенеджерРасписаний = менеджер;
        this.Настройки = Настройки;

        Свойства = new ОбразСвойств();

        Свойства.Позиция = -1;
        Свойства.Размер = 0;
        Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_ВЫВОД;
        Свойства.ПредыдущЭлемент = ЭЛЕМЕНТ_ВЫВОД;

        Свойства.ЧислоЗначение = 0;
        Свойства.ИмяЗначение = "";
        Свойства.СтрокаЗначение = "";

        this.Текст = Текст;
        Свойства.Размер = Текст.length();

        Переменные = new ОбразПеременных();
    }

    // </editor-fold>

    // <editor-fold desc=" Методы класса ">

    void Очистить() {

        Переменные.Значения.removeAllElements();
        Переменные.Имена.removeAllElements();
        Переменные.Свойства.removeAllElements();

        Текст = "";

        Свойства.Позиция = -1;
        Свойства.Размер = 0;
        Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_ВЫВОД;
        Свойства.ПредыдущЭлемент = ЭЛЕМЕНТ_ВЫВОД;

        Свойства.ЧислоЗначение = 0;
        Свойства.ИмяЗначение = "";
        Свойства.СтрокаЗначение = "";
        Свойства.Размер = 0;
    }


    // Оператор Унарный МИНУС.
    public ОбразРезультата операторМИНУС( ОбразРезультата Число ) {

        Integer тип = (Integer) Число.Тип.elementAt(0);
        ОбразРезультата Результат = null;

        switch ( тип.intValue() ){

            case ТИП_СКАЛЯР:

                Integer врм = (Integer) Число.Значение.elementAt(0);
                Результат = new ОбразРезультата( -врм.intValue() );
                break;
        }

        return Результат;
    }


    // Оператор МИНУС.
    public ОбразРезультата операторМИНУС( ОбразРезультата Число1, ОбразРезультата Число2 ) {

        Integer тип = (Integer) Число1.Тип.elementAt(0);
        ОбразРезультата Результат = null;

        switch ( тип.intValue() ){

            case ТИП_СКАЛЯР:

                Integer число1 = (Integer) Число1.Значение.elementAt(0);
                Integer число2 = (Integer) Число2.Значение.elementAt(0);

                Результат = new ОбразРезультата( число1.intValue() - число2.intValue() );
                break;
        }

        return Результат;
    }


    // Оператор ПЛЮС.
    public ОбразРезультата операторПЛЮС( ОбразРезультата Число1, ОбразРезультата Число2 ) {

        Integer тип = (Integer) Число1.Тип.elementAt(0);
        ОбразРезультата Результат = null;

        switch ( тип.intValue() ){

            case ТИП_СКАЛЯР:

                Integer число1 = (Integer) Число1.Значение.elementAt(0);
                Integer число2 = (Integer) Число2.Значение.elementAt(0);

                Результат = new ОбразРезультата( число1.intValue() + число2.intValue() );
                break;
        }

        return Результат;
    }


    // Оператор УМНОЖИТЬ.
    public ОбразРезультата операторУМНОЖИТЬ( ОбразРезультата Число1, ОбразРезультата Число2 ) {

        Integer тип = (Integer) Число1.Тип.elementAt(0);
        ОбразРезультата Результат = null;

        switch ( тип.intValue() ){

            case ТИП_СКАЛЯР:

                Integer число1 = (Integer) Число1.Значение.elementAt(0);
                Integer число2 = (Integer) Число2.Значение.elementAt(0);

                Результат = new ОбразРезультата( число1.intValue() * число2.intValue() );
                break;
        }

        return Результат;
    }


    // Оператор ДЕЛИТЬ.
    public ОбразРезультата операторДЕЛИТЬ( ОбразРезультата Число1, ОбразРезультата Число2 ) {

        Integer тип = (Integer) Число1.Тип.elementAt(0);
        ОбразРезультата Результат = null;

        switch ( тип.intValue() ){

            case ТИП_СКАЛЯР:

                Integer число1 = (Integer) Число1.Значение.elementAt(0);
                Integer число2 = (Integer) Число2.Значение.elementAt(0);

                Результат = new ОбразРезультата( число1.intValue() / число2.intValue() );
                break;
        }

        return Результат;
    }


    // Оператор СТЕПЕНЬ.
    public ОбразРезультата операторСТЕПЕНЬ( ОбразРезультата Число, ОбразРезультата Степень ) {

        Integer тип = (Integer) Число.Тип.elementAt(0);
        ОбразРезультата Результат = null;

        switch ( тип.intValue() ){

            case ТИП_СКАЛЯР:

                Integer число = (Integer) Число.Значение.elementAt(0);
                Integer степень = (Integer) Степень.Значение.elementAt(0);
                int рез = число.intValue();

                for ( int ii = 1; ii < степень.intValue(); ii++ ) рез *= число.intValue();

                Результат = new ОбразРезультата( рез );
                break;
        }

        return Результат;
    }


    public ОбразРезультата операторSTACK( ОбразРезультата вектор ) throws Exception {

        Integer тип = ( Integer ) вектор.Тип.elementAt(0);
        ОбразРезультата Результат = null;

        switch ( тип.intValue() ){

            case ТИП_СКАЛЯР:
            case ТИП_СТРОКА:
            case ТИП_ВЕКТОР_1x1:
            case ТИП_ВЕКТОР_СТОЛБЕЦ:

                Vector врм = new Vector();
                врм.addElement( вектор );

                Результат = new ОбразРезультата( 1, 1, врм );
                break;
        }

        return Результат;
    }


    public ОбразРезультата операторSTACK( ОбразРезультата вектор, ОбразРезультата элемент ) throws Exception {

        Integer тип = ( Integer ) вектор.Тип.elementAt(0);
        ОбразРезультата Результат = null;

        switch ( тип.intValue() ){

            case ТИП_СКАЛЯР:
            case ТИП_СТРОКА:
            case ТИП_ВЕКТОР_1x1:

                Vector врм = new Vector();
                врм.addElement( вектор );
                врм.addElement( элемент );

                Результат = new ОбразРезультата( 2, 1, врм );
                break;

            case ТИП_ВЕКТОР_СТОЛБЕЦ:

                Vector данные = ( Vector ) вектор.Значение.elementAt(0);
                данные.addElement( элемент );
                int строк = ( ( Integer ) вектор.Размер.elementAt(0) ).intValue() + 1;

                Результат = new ОбразРезультата( строк, 1, данные );
                break;
        }

        return Результат;
    }


    public char Символ() {

        if ( Свойства.Позиция >= ( Свойства.Размер - 1 ) ) return ' ';

        return Текст.charAt( (int) ++Свойства.Позиция );
    }


    public int ПолучитьЭлемент() throws Exception {

        char Литера;

        do {

            if ( Свойства.Позиция >= ( Свойства.Размер - 1 ) ) {

                Свойства.ПредыдущЭлемент = Свойства.ТекущийЭлемент;
                return Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_КОНЕЦ;
            }

            Литера = Символ();

        } while ( ( Литера == ' ' )
                || ( Литера == '\t' )
                || ( Литера == '\r' )
                || ( Литера == '\n' ) );

        // Множество управляющих символов.
        if ( Литера == ';' ) {

            Свойства.ПредыдущЭлемент = Свойства.ТекущийЭлемент;
//            if ( Свойства.Позиция >= ( Свойства.Размер - 1 ) ) {
//                return ( Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_КОНЕЦ );
//            }
            return ( Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_ВЫВОД );


        // Множество операций.
        } else if ( Литера == '*' ) {

            Свойства.ПредыдущЭлемент = Свойства.ТекущийЭлемент;
            return ( Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_УМНОЖИТЬ );


        } else if ( Литера == '/' ) {

            long врм = Свойства.Позиция;

            Литера = Символ();

            // Пропуск строчного комментария.
            if ( Литера == '/' ) {

                do {

                    if ( Свойства.Позиция >= ( Свойства.Размер - 1 ) ) {

                        Свойства.ПредыдущЭлемент = Свойства.ТекущийЭлемент;
                        return Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_КОНЕЦ;
                    }

                    Литера = Символ();

                } while ( !( ( Литера == '\r' ) || ( Литера == '\n' ) ) );

                return ПолучитьЭлемент();

            } else {

                Свойства.Позиция = врм;
            }

            Свойства.ПредыдущЭлемент = Свойства.ТекущийЭлемент;
            return ( Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_ДЕЛИТЬ );


        } else if ( Литера == '+' ) {

            Свойства.ПредыдущЭлемент = Свойства.ТекущийЭлемент;
            return ( Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_ПЛЮС );


        } else if ( Литера == '-' ) {

            Свойства.ПредыдущЭлемент = Свойства.ТекущийЭлемент;
            return ( Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_МИНУС );


        } else if ( Литера == '^' ) {

            Свойства.ПредыдущЭлемент = Свойства.ТекущийЭлемент;
            return ( Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_СТЕПЕНЬ );


        } else if ( Литера == '!' ) {

            Свойства.ПредыдущЭлемент = Свойства.ТекущийЭлемент;
            return ( Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_ФАКТОРИАЛ );


        } else if ( Литера == '(' ) {

            Свойства.ПредыдущЭлемент = Свойства.ТекущийЭлемент;
            return ( Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_ЛЕВАЯСКОБКА );


        } else if ( Литера == '[' ) {

            Свойства.ПредыдущЭлемент = Свойства.ТекущийЭлемент;
            return ( Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_ЛЕВАЯКВАДРСКОБКА );


        } else if ( Литера == ']' ) {

            Свойства.ПредыдущЭлемент = Свойства.ТекущийЭлемент;
            return ( Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_ПРАВАЯКВАДРСКОБКА );


        } else if ( Литера == ')' ) {

            Свойства.ПредыдущЭлемент = Свойства.ТекущийЭлемент;
            return ( Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_ПРАВАЯСКОБКА );


        } else if ( Литера == '=' ) {

            Свойства.ПредыдущЭлемент = Свойства.ТекущийЭлемент;
            return ( Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_ПРИСВОИТЬ );


        } else if ( Литера == ',' ) {

            Свойства.ПредыдущЭлемент = Свойства.ТекущийЭлемент;
            return ( Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_ЗАПЯТАЯ );

        // Строка текста, заключённая в кавычки.
        } else if ( Литера == '"' ) {

            Свойства.СтрокаЗначение = "";
            Литера = Символ();

            while ( Литера != '"' ) {

                Свойства.СтрокаЗначение += Литера;
                Литера = Символ();
            }

            Свойства.ПредыдущЭлемент = Свойства.ТекущийЭлемент;
            return ( Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_ТЕКСТ );


        // Множество целых чисел
        } else if ( ( Литера >= '0' ) && ( Литера <= '9' ) ) {

            String Число = "" + Литера;
            Литера = Символ();

            while ( ( ( Литера >= '0' ) && ( Литера <= '9' ) ) ) {

                Число += Литера;
                Литера = Символ();
            }

            Свойства.ЧислоЗначение = Integer.parseInt( Число );
            Свойства.Позиция--; // возвращаем позицию на предыдущий символ
            Свойства.ПредыдущЭлемент = Свойства.ТекущийЭлемент;

            return ( Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_ЧИСЛО );


        // Множество имён.
        } else if ( ( ( Литера >= 'a' ) && ( Литера <= 'z' ) )
                || ( ( Литера >= 'A' ) && ( Литера <= 'Z' ) )
                || ( ( Литера >= 'А' ) && ( Литера <= 'я' ) )
                || ( Литера == 'Ё' )
                || ( Литера == 'ё' )
                || ( Литера == '_' )
                ) {

            Свойства.ИмяЗначение = "" + Литера;
            Литера = Символ();

            while ( ( ( Литера >= 'a' ) && ( Литера <= 'z' ) )
                    || ( ( Литера >= 'A' ) && ( Литера <= 'Z' ) )
                    || ( ( Литера >= 'А' ) && ( Литера <= 'я' ) )
                    || ( Литера == 'Ё' )
                    || ( Литера == 'ё' )
                    || ( ( Литера >= '0' ) && ( Литера <= '9' ) )
                    || ( Литера == '.' )
                    || ( Литера == '_' )
                    ) {

                Свойства.ИмяЗначение += Литера;
                Литера = Символ();

            }

            // возвращаем позицию на предыдущий символ.
            Свойства.Позиция--;
            Свойства.ПредыдущЭлемент = Свойства.ТекущийЭлемент;

            // Ключевые слова
            if ( ( Свойства.ИмяЗначение.equals( "true" )
                    || ( Свойства.ИмяЗначение.equals( "false" ) )
                    ) ) {

                return ( Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_КЛЮЧЕВОЕ_СЛОВО );
            }

            return ( Свойства.ТекущийЭлемент = ЭЛЕМЕНТ_ИМЯ );
        }

        throw new ИсключениеРазборщика( ОШИБКА_НЕИЗВЕСТНЫЙ_СИМВОЛ );
    }


    public ОбразРезультата ОсновныеОперации( boolean продолжать ) throws Exception {

        ОбразРезультата Результат;

        if ( продолжать ) ПолучитьЭлемент();

        switch ( Свойства.ТекущийЭлемент ) {

            case ЭЛЕМЕНТ_КОНЕЦ:
            case ЭЛЕМЕНТ_ВЫВОД:
                return null;
        }

        if ( Свойства.ТекущийЭлемент == ЭЛЕМЕНТ_ЧИСЛО ) {

            Результат = new ОбразРезультата( Свойства.ЧислоЗначение );
            ПолучитьЭлемент();
            return Результат;


        } else if ( Свойства.ТекущийЭлемент == ЭЛЕМЕНТ_КЛЮЧЕВОЕ_СЛОВО ) {

            if ( Свойства.ИмяЗначение.equals( "true" ) ) {

                Результат = new ОбразРезультата( true );
                ПолучитьЭлемент();
                return Результат;

            } else if ( Свойства.ИмяЗначение.equals( "false" ) ) {

                Результат = new ОбразРезультата( false );
                ПолучитьЭлемент();
                return Результат;
            }

            throw new ИсключениеРазборщика( ОШИБКА_НЕИЗВЕСТНОЕ_КЛЮЧЕВОЕ_СЛОВО );


        } else if ( Свойства.ТекущийЭлемент == ЭЛЕМЕНТ_ИМЯ ) {

            ОбразСвойств врм;
            String имя = Свойства.ИмяЗначение;

            врм = Свойства;
            Свойства = new ОбразСвойств( врм );
            ПолучитьЭлемент();

            if ( Свойства.ТекущийЭлемент == ЭЛЕМЕНТ_ПРИСВОИТЬ ) {

                Свойства = врм;
                return ОсновныеОперации( true );
            }

            Свойства = врм;

            if ( Переменные.ИмяВТаблице( имя ) ) {

                int свойство = Переменные.СвойствоЭлемента( имя );

                if ( ( свойство == СВОЙСТВО_КОНСТАНТА ) || ( свойство == СВОЙСТВО_ПЕРЕМЕННАЯ ) ) {

                    ОбразРезультата знач = Переменные.ЗначениеЭлемента( имя );
                    ПолучитьЭлемент();
                    return знач;
                }

            } else {

                throw new ИсключениеРазборщика( ОШИБКА_НЕИЗВЕСТНЫЙ_ИДЕНТИФИКАТОР );
            }

            return ОсновныеОперации( true );


        } else if ( Свойства.ТекущийЭлемент == ЭЛЕМЕНТ_ПРИСВОИТЬ ) {

            ОбразСвойств врм;
            врм = Свойства;
            Свойства = new ОбразСвойств( врм );
            ПолучитьЭлемент();

            if ( ( Свойства.ТекущийЭлемент == ЭЛЕМЕНТ_ВЫВОД ) || ( Свойства.ТекущийЭлемент == ЭЛЕМЕНТ_КОНЕЦ ) ) {

                throw new ИсключениеРазборщика( ОШИБКА_ОЖИДАЕТСЯ_ВЫВОД );
            }

            Свойства = врм;

            if ( Свойства.ПредыдущЭлемент == ЭЛЕМЕНТ_ИМЯ ) {

                String имя = Свойства.ИмяЗначение;

                if ( Переменные.ИмяВТаблице( имя ) ) {

                    int свойство = Переменные.СвойствоЭлемента( имя );

                    if ( свойство == СВОЙСТВО_ПЕРЕМЕННАЯ ) {

                        ОбразРезультата знач = СложениеВычитание( true );
                        Переменные.ИзменитьЭлемент( имя, свойство, знач );
                        ПолучитьЭлемент();
                        return знач;
                    }

                    throw new ИсключениеРазборщика( ОШИБКА_ИЗМЕНИТЬ_НЕЛЬЗЯ );

                } else {

                    ОбразРезультата знач = СложениеВычитание( true );
                    Переменные.ДобавитьЭлемент( имя, СВОЙСТВО_ПЕРЕМЕННАЯ, знач );
                    ПолучитьЭлемент();
                    return знач;
                }

            }

            throw new ИсключениеРазборщика( ОШИБКА_ПРИ_ПРИСВОЕНИИ );


        } else  if ( Свойства.ТекущийЭлемент == ЭЛЕМЕНТ_ТЕКСТ ) {

            Результат = new ОбразРезультата( Свойства.СтрокаЗначение );
            ПолучитьЭлемент();
            return Результат;


        // Унарный минус.
        } else if ( Свойства.ТекущийЭлемент == ЭЛЕМЕНТ_МИНУС ) {

            return операторМИНУС( УмножениеДеление( true ) );


        } else if ( Свойства.ТекущийЭлемент == ЭЛЕМЕНТ_ЛЕВАЯСКОБКА ) {

            if ( Свойства.ПредыдущЭлемент == ЭЛЕМЕНТ_ИМЯ ) {

                String имя = Свойства.ИмяЗначение;
                int свойство = Переменные.СвойствоЭлемента( имя );

                if ( свойство == СВОЙСТВО_ФУНКЦИЯ ) {

                    ОбразРезультата знач = Список( true );

                    if ( Свойства.ТекущийЭлемент != ЭЛЕМЕНТ_ПРАВАЯСКОБКА )
                        throw new ИсключениеРазборщика( ОШИБКА_ОЖИДАЕТСЯ_ПРАВАЯ_СКОБКА );

                    ПолучитьЭлемент();
                    return Функция( имя, знач );

                } else {

                    throw new ИсключениеРазборщика( ОШИБКА_НЕСООТВЕТСТВИЕ_ТИПА );
                }

            }

            Результат = СложениеВычитание( true );

            if ( Свойства.ТекущийЭлемент != ЭЛЕМЕНТ_ПРАВАЯСКОБКА )
                throw new ИсключениеРазборщика( ОШИБКА_ОЖИДАЕТСЯ_ПРАВАЯ_СКОБКА );

            ПолучитьЭлемент();
            return Результат;


        } else if ( Свойства.ТекущийЭлемент == ЭЛЕМЕНТ_ЛЕВАЯКВАДРСКОБКА ) {

            ОбразРезультата знач = Список( true );

            if ( Свойства.ТекущийЭлемент != ЭЛЕМЕНТ_ПРАВАЯКВАДРСКОБКА )
                throw new ИсключениеРазборщика( ОШИБКА_ОЖИДАЕТСЯ_ПРАВАЯ_КВАДР_СКОБКА );

            ПолучитьЭлемент();
            Vector врм = ( Vector ) знач.Значение.elementAt(0);
            int строк = ( ( Integer ) знач.Размер.elementAt(0) ).intValue();

            return операторSTACK( new ОбразРезультата( строк, 1, врм ) );
        }

        return null;
    }


    public ОбразРезультата Функция( String имя, ОбразРезультата параметры ) throws Exception {

        Integer тип = ( Integer ) параметры.Тип.elementAt(0);
        ОбразРезультата Результат = null;

        switch ( тип.intValue() ){

            case ТИП_СКАЛЯР:

                Integer число = ( Integer ) параметры.Значение.elementAt(0);
                //...
                break;

            case ТИП_СТРОКА:

                String строка = ( String ) параметры.Значение.elementAt(0);
                //...
                break;

//            case ТИП_ВЕКТОР_1x1:
            case ТИП_ВЕКТОР_СТОЛБЕЦ:

                Vector данные = ( Vector ) параметры.Значение.elementAt(0);

                if ( имя.equals( "ДобавитьГруппу" ) ) {

                    int строк = ( ( Integer ) параметры.Размер.elementAt(0) ).intValue();

                    ОбразРезультата врм;
                    Record Запись = new Record();

                    врм = ( ОбразРезультата ) данные.elementAt(0);
                    Запись.Верх = ( ( Integer ) врм.Значение.elementAt(0) ).intValue();

                    врм = ( ОбразРезультата ) данные.elementAt(1);
                    Запись.ТипЗаписи = ( ( Integer ) врм.Значение.elementAt(0) ).intValue();

                    врм = ( ОбразРезультата ) данные.elementAt(2);
                    Запись.Имя = ( String ) врм.Значение.elementAt(0);

                    Запись.Часы = 0;
                    Запись.Минуты = 0;
                    Запись.Секунды = 0;
                    Запись.ТипЗвонка = Schedules.ТИП_СВОБОДНЫЙ;
                    Запись.ПутьОсновн = "";
                    Запись.ПутьПредвар = "";

                    return new ОбразРезультата( МенеджерРасписаний.Данные.Добавить( Запись ) );


                } else if ( имя.equals( "ДобавитьЗвонок" ) ) {

                    int строк = ( ( Integer ) параметры.Размер.elementAt(0) ).intValue();
                    String cтр;
                    ОбразРезультата врм;

                    Record Запись = new Record();

                    врм = ( ОбразРезультата ) данные.elementAt(0);
                    Запись.Верх = ( ( Integer ) врм.Значение.elementAt(0) ).intValue();

                    врм = ( ОбразРезультата ) данные.elementAt(1);
                    Запись.Часы = ( ( Integer ) врм.Значение.elementAt(0) ).intValue();

                    врм = ( ОбразРезультата ) данные.elementAt(2);
                    Запись.Минуты = ( ( Integer ) врм.Значение.elementAt(0) ).intValue();

                    врм = ( ОбразРезультата ) данные.elementAt(3);
                    Запись.ТипЗвонка = ( ( Integer ) врм.Значение.elementAt(0) ).intValue();

                    врм = ( ОбразРезультата ) данные.elementAt(4);
                    Запись.ПутьОсновн = ( String ) врм.Значение.elementAt(0);

                    врм = ( ОбразРезультата ) данные.elementAt(5);
                    Запись.ПутьПредвар = ( String ) врм.Значение.elementAt(0);

                    cтр = "" + ( ( Запись.Часы < 10 ) ? "0" : "" ) + Запись.Часы +
                        "." + ( ( Запись.Минуты < 10 ) ? "0" : "" ) + Запись.Минуты;
                    Запись.Имя = cтр;

                    Запись.Секунды = 0;
                    Запись.ТипЗаписи = Schedules.ТИП_ЗВОНОК;

                    return new ОбразРезультата( МенеджерРасписаний.Данные.Добавить( Запись ) );


                } else if ( имя.equals( "ДобавитьПлан" ) ) {

                    int строк = ( ( Integer ) параметры.Размер.elementAt(0) ).intValue();
                    String cтр;
                    ОбразРезультата врм, Месяц, Число;
                    Vector век, век2;

                    Record Запись = new Record();

                    врм = ( ОбразРезультата ) данные.elementAt(0);
                    Запись.Имя = ( String ) врм.Значение.elementAt(0);

                    врм = ( ОбразРезультата ) данные.elementAt(1);
                    век = ( Vector ) врм.Значение.elementAt(0);
                    врм = ( ОбразРезультата ) век.elementAt(0);
                    век = ( Vector ) врм.Значение.elementAt(0);
                    cтр = "[";

                    for ( int ii = 0; ii < 12; ii++ ) {

                        cтр += "[";
                        врм = ( ОбразРезультата ) век.elementAt(ii);
                        век2 = ( Vector ) врм.Значение.elementAt(0);
                        Месяц = ( ОбразРезультата ) век2.elementAt(0);
                        век2 = ( Vector ) Месяц.Значение.elementAt(0);

                        for ( int jj = 0; jj < 31; jj++ ) {

                            Число = ( ОбразРезультата ) век2.elementAt(jj);
                            cтр += "" + ( ( Integer ) Число.Значение.elementAt(0) ).intValue();
                            cтр += ( jj < 30 ) ? "," : "";

                        }

                        cтр += ( ii < 11 ) ? "]," : "]";

                    }

                    cтр += "];";
                    Запись.ПутьОсновн = cтр;

                    врм = ( ОбразРезультата ) данные.elementAt(2);
                    век = ( Vector ) врм.Значение.elementAt(0);
                    врм = ( ОбразРезультата ) век.elementAt(0);
                    век = ( Vector ) врм.Значение.elementAt(0);
                    cтр = "[";

                    for ( int ii = 0; ii < 12; ii++ ) {

                        cтр += "[";
                        врм = ( ОбразРезультата ) век.elementAt(ii);
                        век2 = ( Vector ) врм.Значение.elementAt(0);
                        Месяц = ( ОбразРезультата ) век2.elementAt(0);
                        век2 = ( Vector ) Месяц.Значение.elementAt(0);

                        for ( int jj = 0; jj < 31; jj++ ) {

                            Число = ( ОбразРезультата ) век2.elementAt(jj);
                            cтр += "" + ( ( Integer ) Число.Значение.elementAt(0) ).intValue();
                            cтр += ( jj < 30 ) ? "," : "";

                        }

                        cтр += ( ii < 11 ) ? "]," : "]";

                    }

                    cтр += "];";
                    Запись.ПутьПредвар = cтр;

                    Запись.Верх = 0;
                    Запись.Часы = 0;
                    Запись.Минуты = 0;
                    Запись.Секунды = 0;
                    Запись.ТипЗаписи = Schedules.ТИП_ПЛАН;
                    Запись.ТипЗвонка = Schedules.ТИП_СВОБОДНЫЙ;

                    return new ОбразРезультата( МенеджерРасписаний.Данные.Добавить( Запись ) );
                }

                break;
        }

        return Результат;
    }


    public ОбразРезультата Список( boolean продолжать ) throws Exception {

        ОбразРезультата ЛеваяЧасть = СложениеВычитание( продолжать );

        while ( true ) {

            if ( Свойства.ТекущийЭлемент == ЭЛЕМЕНТ_ЗАПЯТАЯ ) {

                ЛеваяЧасть = операторSTACK( ЛеваяЧасть, СложениеВычитание( true ) );

            } else return ЛеваяЧасть;
        }

    }


    public ОбразРезультата ВозведениеВСтепень( boolean продолжать ) throws Exception {

        ОбразРезультата ЛеваяЧасть = ОсновныеОперации( продолжать );

        while ( true ) {

            if ( Свойства.ТекущийЭлемент == ЭЛЕМЕНТ_СТЕПЕНЬ ) {

                ЛеваяЧасть = операторСТЕПЕНЬ( ЛеваяЧасть, ОсновныеОперации( true ) );

            } else return ЛеваяЧасть;

        }

    }


    public ОбразРезультата УмножениеДеление( boolean продолжать ) throws Exception {

        ОбразРезультата ЛеваяЧасть = ВозведениеВСтепень( продолжать );

        while ( true ) {

            if ( Свойства.ТекущийЭлемент == ЭЛЕМЕНТ_УМНОЖИТЬ ) {

                ЛеваяЧасть = операторУМНОЖИТЬ( ЛеваяЧасть, ВозведениеВСтепень( true ) );

            } else if ( Свойства.ТекущийЭлемент == ЭЛЕМЕНТ_ДЕЛИТЬ ) {

                ОбразРезультата знач = ВозведениеВСтепень( true );

                Integer врм = ( Integer ) знач.Значение.elementAt(0);

                if ( врм.intValue() == 0 ) throw new ИсключениеРазборщика( ОШИБКА_ДЕЛЕНИЕ_НА_НОЛЬ );

                ЛеваяЧасть = операторДЕЛИТЬ( ЛеваяЧасть, знач );

            } else return ЛеваяЧасть;

        }

    }


    public ОбразРезультата СложениеВычитание( boolean продолжать ) throws Exception {

        ОбразРезультата ЛеваяЧасть = УмножениеДеление( продолжать );

        while ( true ) {

            if ( Свойства.ТекущийЭлемент == ЭЛЕМЕНТ_ПЛЮС ) {

                ЛеваяЧасть = операторПЛЮС( ЛеваяЧасть, УмножениеДеление( true ) );

            } else if ( Свойства.ТекущийЭлемент == ЭЛЕМЕНТ_МИНУС ) {

                ЛеваяЧасть = операторМИНУС( ЛеваяЧасть, УмножениеДеление( true ) );

            } else return ЛеваяЧасть;
        }

    }

    // </editor-fold>

}
